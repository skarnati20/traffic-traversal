import copy
import math
import random
from typing import Optional, List


class TrafficNode:
    """
    A class used to represent a node (or vertex) in our graph. Each node is
    positioned in a Cartesian plane.

    ...
    Attributes
    __________
    name : str
        A name for the node
    x : float
        The x position on the Cartesian plane
    y : float
        The y position on the Cartesian plane
    """

    def __init__(self, name: str, x: float, y: float):
        self.name = name
        self.x = x
        self.y = y


class TrafficEdge:
    """
    A class used to represent an edge between two nodes in our graph. Each node
    has a standard weight, but we may derive an adjusted weigh based on how
    many agents are in its queue.

    ...
    Attributes
    __________
    weight : float
        A float representing the weight of the edge whenever one or less agents
        occupy the edge
    queue : List[(int, int)]
        A queue that holds the agent's occupancy at a given time step
    """

    def __init__(self, weight: float):
        self.weight = weight
        self.queue = []

    def add_agent(self, agent_index: int, time_step: int):
        """
        Adds an agent at the given time step to the edge's queue.

        Parameters
        __________
        agent_index : int
            An agent represented by an integer
        time_step : int
            The time step at which the agent occupies the edge
        """
        if agent_index not in self.queue:
            self.queue.append((agent_index, time_step))

    def remove_agent(self, agent_index: int):
        """
        Removes an agent from the edge's queue.

        Parameters
        __________
        agent_index : int
            An agent represented by an integer
        """
        self.queue = [
            (agent, time) for (agent, time) in self.queue if agent != agent_index
        ]

    def clear_queue(self):
        """
        Clears all agents from the edge's queue.
        """
        self.queue.clear()

    def calculate_weight(self, time_step: int) -> float:
        """
        Calculates the weight at the edge for a given time step.

        Parameters
        __________
        time_step : int
            The time step for which you want to calculate the edge's weight

        Returns
        _______
        A float of the weight
        """
        # Check how many agents there are at a given time step
        count = 0
        for _, time in self.queue:
            if time_step == time:
                count += 1
        if count == 0:
            return self.weight
        # For each agent over one, we will add half the initial weight
        return self.weight + (0.5 * self.weight) * (count - 1)


class TrafficState:
    """
    A class used to represent the state of a traffic graph.

    Agents are either in the complete list, meaning they are allocated at the
    coming time step, `n`, while those agents in the incomplete list have only
    been allocated for the previous time step, `n - 1`. Note: there is no need,
    however, to keep track of the current time step. This step-by-step building
    process is critical for the M* style algorithms.

    This class also holds information about each agent's paths, as well as their
    planned paths at a given point (generated by A*).

    ...
    Attributes
    __________
    complete : List[int]
        A list of agents who at this time step have been allocated completely
    incomplete : List[int]
        A list of agents who at this time step need to be allocated and are one
        time step behind those agents in the complete list
    paths : List[List[str]]
        A list of current traversal paths, whose index `i` corresponds to the
        agent `i`
    a_star_plans : List[List[str]]
        A list of planned paths based on the A* algorithm, whose index `i`
        corresponds to the agent `i`
    """

    def __init__(self):
        self.complete = []
        self.incomplete = []
        self.paths = []
        self.a_star_plans = []


class TrafficGraph:
    """
    A class used to represent a traffic graph. As any graph representation, it
    consists of nodes and edges that connect between them.

    ...
    Attributes
    __________
    nodes : Dict(str : TrafficNode)
        A dictionary that maps a node's name to its TrafficNode object
    edges : Dict((str, str) : TrafficEdge)
        A dictionary that maps a tuple pair of nodes to the associated
        TrafficEdge object
    graph : Dict(str : List[(str, TrafficEdge)])
        A dictionary that maps a node with a list of its neighboring connections,
        represented by a tuple pair of the node's and the TrafficEdge that
        connects the nodes together
    """

    def __init__(self):
        self.nodes = {}
        self.edges = {}
        self.graph = {}

    def add_node(self, name: str, x: float, y: float):
        """
        Adds a node to the traffic graph.

        Parameters
        __________
        name : str
            The name of the node
        x : float
            The node's x position
        y : float
            The node's y position
        """
        self.nodes[name] = TrafficNode(name, x, y)

    def get_euclidean_distance(self, a: str, b: str) -> float:
        """ "
        Calculate the euclidean distance between two nodes

        Parameters
        __________
        a : str
        b : str
            Two graph nodes

        Returns
        _______
        A float representing the euclidean distance. Returns -1 if either node
        does not exist in the graph.
        """
        if not (a in self.nodes) or not (b in self.nodes):
            return -1
        node_a = self.nodes[a]
        node_b = self.nodes[b]
        return math.sqrt(
            math.pow((node_a.x - node_b.x), 2) + math.pow((node_a.y - node_b.y), 2)
        )

    def add_edge(self, a: str, b: str, weight: Optional[float] = None):
        """
        Adds an edge between two nodes with a given weight. If a weight is not
        specified, then the edge takes the euclidean distance between the nodes.

        Parameters
        __________
        a : str
        b : str
            Two graph nodes
        weight : Optional[float]
            An optional weight for the edge
        """
        if not a in self.nodes or not b in self.nodes:
            return
        new_edge = TrafficEdge(0)
        if weight:
            new_edge.weight = weight
        else:
            new_edge.weight = self.get_euclidean_distance(a, b)
        self.edges[(a, b)] = new_edge
        self.graph[a] = self.graph.get(a, []) + [(b, new_edge)]

    def read_graph_from_file(self, path: str):
        """
        Reads a graph from a file and populates our graph object with the file's
        nodes and edges.

        The file must comprise of two texts blocks: the first contains the
        node initialization (<node_name>,<x_value>,<y_value>), and the second
        contains an edge initialization (<node_a_name>,<node_b_name>) or
        (<node_a_name>,<node_b_name>,<edge_weight>).

        Here is an example:
        `
        a,0,0
        b,2,1
        c,1,2
        d,3,3

        a,b,5
        b,d,3
        a,c,4
        c,d,3
        `

        Parameters
        __________
        path : str
            A file path for our graph
        """
        # Clear current graph
        self.nodes = {}
        self.edges = {}
        self.graph = {}

        f = open(path)
        lines = f.readlines()
        i = 0
        # Traverse through block of nodes
        while i < len(lines):
            if not lines[i].strip():
                i += 1
                break
            node = lines[i].split(",")
            if len(node) == 3:
                self.add_node(node[0].strip(), float(node[1]), float(node[2]))
            i += 1
        # Traverse through block of edges
        while i < len(lines):
            edge = lines[i].split(",")
            if len(edge) == 2:
                self.add_edge(edge[0].strip(), edge[1].strip())
            elif len(edge) == 3:
                self.add_edge(edge[0].strip(), edge[1].strip(), float(edge[2]))
            i += 1

    def get_edge(self, a: str, b: str) -> Optional[TrafficEdge]:
        """
        Gets the associated edge between the two passed in nodes.

        Parameters
        __________
        a : str
        b : str
            Two graph nodes

        Returns
        _______
        A TrafficEdge betweent he nodes. None if the edge does not exist.
        """
        return self.edges.get((a, b), None)

    def clear_edge_queues(self):
        """
        Clears each edge's agent queue.
        """
        for edge in self.edges.values():
            edge.clear_queue()

    def print_graph(self):
        """
        Prints the list of traffic nodes and edges in the graph.
        """
        print("Traffic Nodes:\n")
        for n in self.nodes:
            print(
                n + ", (" + str(self.nodes[n].x) + ", " + str(self.nodes[n].y) + ")\n"
            )
        print("Traffic Edges:\n")
        for n in self.edges:
            print(str(n) + ", weight: " + str(self.edges[n].weight))

    def compute_single_path_cost(self, path: List[str]) -> float:
        """
        Computes the cost of a path using the standard weight for each edge.

        Parameters
        __________
        path : List[str]
            A list of nodes representing a path traversal

        Returns
        _______
        The cost of the path. If no path is possible, return -1.
        """
        if len(path) == 0:
            return -1
        cost = 0
        curr = path[0]
        for i in range(1, len(path)):
            next = path[i]
            if (curr, next) in self.edges:
                edge = self.edges[(curr, next)]
                cost += edge.weight
                curr = next
            else:
                return -1
        return cost

    def compute_multi_path_cost(self, paths: List[List[str]]) -> List[float]:
        """
        Computes the cost of multiple concurrent paths. Unlike the method
        `compute_single_path_cost`, we use the adjusted weight based off the
        number of agents also queued up to traverse each edge.

        Parameters
        __________
        paths : List[List[str]]
            A list of paths (of type List[str]). Each index represents a
            different agent's path

        Returns
        _______
        A list of floats, where a cost at index `i` corresponds to the cost
        of the path at index `i` in `paths`. If the path is invalid, a value of
        -1 is set int the returned cost list.
        """
        # Create initial array to keep track of progress
        costs = []
        indices = []
        curr = []

        # Go through an initial pass through index 0 to give us a starting point
        for path in paths:
            if len(path) == 0:
                # If path array is empty, make it return a cost of -1 and append
                # None to the current nodes
                costs.append(-1)
                indices.append(0)
                curr.append(None)
                continue
            costs.append(0)
            indices.append(1)
            curr.append(path[0])

        while not all(c == None for c in curr):
            self.clear_edge_queues()

            # Add yourself first to the next edge, so we can figure out the
            # updated weight afterward
            for i in range(len(paths)):
                path_index = indices[i]
                path = paths[i]
                if path_index < len(path) and curr[i]:
                    next = path[path_index]
                    if not (curr[i], next) in self.edges:
                        costs[i] = -1
                        curr[i] = None
                    else:
                        # Set time step to -1 since it doesn't need to be exact
                        self.edges[(curr[i], next)].add_agent(i, -1)
                elif curr[i]:
                    curr[i] = None

            # After all the agents have added themselves to the next edge, we
            # update the costs of each path so far
            for i in range(len(paths)):
                path_index = indices[i]
                path = paths[i]
                if (
                    path_index < len(path)
                    and curr[i]
                    and (curr[i], path[path_index]) in self.edges
                ):
                    # Calculate the time step at the spoof time step -1
                    costs[i] += self.edges[
                        (curr[i], path[path_index])
                    ].calculate_weight(-1)
                    curr[i] = path[path_index]
                indices[i] += 1
        return costs

    def a_star_single_traversal(self, start: str, end: str) -> List[str]:
        """
        Performs an A* traversal on the graph for the given start and end node.

        Parameters
        __________
        start : str
        end : str
            The start and end nodes for the traversal

        Returns
        _______
        A List[str] of the optimal path, given the state of the graph's edges.
        If not path is possible, it returns an empty list.
        """
        # Establish open and closed list
        open = [(0, start)]
        closed = []
        # Keep track of the best possible costs and paths to each node
        costs = {start: 0}
        paths = {start: [start]}

        while open:
            # Pop the top of the stack and add it to the closed list
            (_, curr_node) = open.pop(0)
            closed.append(curr_node)

            if curr_node == end:
                # In case our heuristic is unsuitable, we make sure not to
                # rule out any options that could yield better results later.
                newOpen = []
                keep_looking = False
                for heur, node in open:
                    if costs[node] < costs[curr_node]:
                        newOpen.append((heur, node))
                        keep_looking = True
                if not keep_looking:
                    # Stop looking, we have our optimal path
                    break
                open = newOpen
                continue

            # Go through the node's children
            for child, edge in self.graph.get(curr_node, []):
                # Add a temporary agent to mimic what would happen if we took
                # this path. If we are doing a single agent traversal, this will
                # not affect the edge calculation.
                edge.add_agent(-1, len(paths[curr_node]))
                child_cost = costs[curr_node] + edge.calculate_weight(
                    len(paths[curr_node])
                )
                edge.remove_agent(-1)

                # If we have found a end path already, only look for paths that
                # are less than its cost.
                if end in costs and costs[end] <= child_cost:
                    continue

                if child in [n for (_, n) in open]:
                    if costs[child] <= child_cost:
                        continue
                elif child in closed:
                    if costs[child] <= child_cost:
                        continue
                    closed.remove(child)
                # If we reach this point, we should be updating to a lower cost
                # path
                open.append(
                    (self.get_euclidean_distance(child, end) + child_cost, child)
                )
                costs[child] = child_cost
                paths[child] = paths[curr_node] + [child]
            open.sort()
        return paths.get(end, [])

    def a_star_multi_traversal(
        self, start_and_end_pairs: List[List[str]]
    ) -> List[List[str]]:
        """
        Performs an A* search for each start and end pair provided in a list.

        Parameters
        __________
        start_and_end_pairs : List[List[str]]
            A list of start and end pairs of nodes to find paths for

        Returns
        _______
        A list of paths whose index corresponds to the index of the requested
        start and end pairs.
        """
        return [
            self.a_star_single_traversal(start, end)
            for (start, end) in start_and_end_pairs
        ]

    def prioritized_planning_traversal(
        self, start_and_end_pairs: List[List[str]]
    ) -> List[List[str]]:
        """
        Performs path traversals by way of randomly shuffled priority orders at
        each turn.

        At each time step, we shuffle the agents in a random order and go
        one-by-one, letting each agent make an A* path based on the previous
        agents' paths.

        Parameters
        __________
        start_and_end_pairs : List[List[str]]
            A list of start and end pairs of nodes to find paths for

        Returns
        _______
        A list of paths whose index corresponds to the index of the requested
        start and end pairs.
        """
        paths = []
        done = []

        for start, _ in start_and_end_pairs:
            if not start in self.nodes:
                paths.append([])
                done.append(True)
            else:
                paths.append([start])
                done.append(False)

        while not all(done):
            # Create random order
            priority = [i for i in range(len(start_and_end_pairs))]
            random.shuffle(priority)

            for i in priority:
                if not done[i]:
                    last_element = paths[i][-1]
                    destination = start_and_end_pairs[i][-1]

                    a_star_path = self.a_star_single_traversal(
                        last_element, destination
                    )
                    if len(a_star_path) == 0:
                        # Only entered when no path is possible
                        paths[i] = []
                        done[i] = True
                    elif len(a_star_path) == 1:
                        # Only entered when we have already reached the
                        # destination
                        done[i] = True
                    else:
                        paths[i] += [a_star_path[1]]

                        # Add the agent to the queue of all edges in its A*
                        # pathway so that future agents will know about it
                        time_step = 1
                        while time_step < len(a_star_path):
                            next_element = a_star_path[time_step]
                            edge = self.edges[(last_element, next_element)]
                            edge.add_agent(i, time_step)
                            time_step += 1
                            last_element = next_element
            self.clear_edge_queues()
        return paths

    def m_star_traversal_priority(self, start_end_pairs) -> List[List[str]]:
        """
        Performs an M* traversal but uses a priority based approach in the event
        of a conflict.

        An M* approach entails expanding a large number of states whenever
        there is a conflict. If when each agent does A* and there are no
        conflicts at a given time step, we make those move. If however, we
        encounter conflicts, we make sure to expand the traffic state in every
        possible priority permutation, similar to the prioritized planning
        approach.

        Parameters
        __________
        start_and_end_pairs : List[List[str]]
            A list of start and end pairs of nodes to find paths for

        Returns
        _______
        A list of paths whose index corresponds to the index of the requested
        start and end pairs.
        """
        initial_state = TrafficState()
        for i, (start, end) in enumerate(start_end_pairs):
            if start in self.nodes and end in self.nodes:
                initial_state.complete.append(i)
                initial_state.paths.append([start])
                initial_state.a_star_plans.append([])
            else:
                return [[]] * len(start_end_pairs)

        states = [(0, initial_state)]
        result = [[]] * len(start_end_pairs)
        result_cost = float("inf")

        while states:
            # Pop the current state off the stack
            (curr_cost, curr_state) = states.pop(0)
            if curr_cost >= result_cost:
                continue
            if len(curr_state.complete) == 0 and len(curr_state.incomplete) == 0:
                # All agents have reached destination, update result if needed
                if curr_cost < result_cost:
                    result = curr_state.paths
                    result_cost = curr_cost
                    continue
            elif len(curr_state.incomplete):
                # If we pop an incomplete vertex, Take the n incomplete nodes
                # and add n new states to graph to advance each by one.
                self.clear_edge_queues()
                for i in curr_state.complete:
                    path = curr_state.paths[i]
                    last_element = path[-2]
                    time_step = 1
                    while time_step < len(curr_state.a_star_plans[i]):
                        next_element = curr_state.a_star_plans[i][time_step]
                        last_edge = self.get_edge(last_element, next_element)
                        last_edge.add_agent(i, time_step)
                        time_step += 1
                        last_element = next_element

                # Add a new state for each incomplete node
                for i in curr_state.incomplete:
                    path = curr_state.paths[i]
                    a_star_path = self.a_star_single_traversal(
                        path[-1], start_end_pairs[i][1]
                    )
                    if a_star_path == []:
                        return [[]] * len(start_end_pairs)

                    new_state = TrafficState()
                    new_state.incomplete = curr_state.incomplete.copy()
                    new_state.complete = curr_state.complete.copy()
                    new_state.paths = copy.deepcopy(curr_state.paths)
                    new_state.a_star_plans = copy.deepcopy(curr_state.a_star_plans)

                    new_state.incomplete.remove(i)
                    new_state.complete.append(i)
                    new_state.paths[i].append(a_star_path[1])
                    new_state.a_star_plans[i] = a_star_path

                    # Update cost if we have completed the vertex
                    new_cost = curr_cost
                    if len(new_state.incomplete) == 0:
                        last_move = []
                        for i in new_state.complete:
                            path = new_state.paths[i]
                            last_move.append([path[-2], path[-1]])
                        new_cost += sum(self.compute_multi_path_cost(last_move))
                    if new_cost < result_cost:
                        states.append((new_cost, new_state))
            else:
                # If we pop a complete vertex:
                # 1. Do A* Star, and advance everyone by their proposed moves
                # 2. If no conflict, add the new state to the state list
                # 3. If there are conflicts, expand the node as if we were dealing
                #    with an incomplete vertex
                self.clear_edge_queues()

                next_move = {}
                for i in curr_state.complete:
                    path = curr_state.paths[i]
                    if path[-1] == start_end_pairs[i][1]:
                        continue
                    a_star_path = self.a_star_single_traversal(
                        path[-1], start_end_pairs[i][1]
                    )
                    if a_star_path == []:
                        return [[]] * len(start_end_pairs)
                    next_move[i] = a_star_path[1]

                if len(next_move.values()) == len(set(next_move.values())):
                    # There is no conflict, the moves are unique
                    new_cost = curr_cost
                    new_state = TrafficState()
                    new_state.paths = curr_state.paths.copy()
                    new_state.a_star_plans = [[]] * len(start_end_pairs)
                    moves = []
                    for i, move in next_move.items():
                        path = curr_state.paths[i]
                        moves.append((path[-1], move))
                        new_state.paths[i].append(move)
                        new_state.complete.append(i)
                    new_cost += sum(self.compute_multi_path_cost(moves))
                    if new_cost < result_cost:
                        states.append((new_cost, new_state))
                else:
                    # There is a conflict, expand the vertex completely
                    new_state = TrafficState()
                    new_state.incomplete = list(next_move.keys())
                    new_state.paths = curr_state.paths.copy()
                    new_state.a_star_plans = [[]] * len(start_end_pairs)
                    if curr_cost < result_cost:
                        states.append((curr_cost, new_state))
            # Sort queue by lowest cost
            states.sort(key=lambda x: x[0])
        return result

    def m_star_traversal_complete(self, start_end_pairs) -> List[List[str]]:
        """
        Performs an M* traversal but expands the state in each direction
        whenever we encounter a conflict.

        NOTE: This solution may not work for graphs that have cycles.

        An M* approach entails expanding a large number of states whenever
        there is a conflict. If when each agent does A* and there are no
        conflicts at a given time step, we make those move. If however, we
        encounter conflicts, we will expand all possible moves for each agent.

        Parameters
        __________
        start_and_end_pairs : List[List[str]]
            A list of start and end pairs of nodes to find paths for

        Returns
        _______
        A list of paths whose index corresponds to the index of the requested
        start and end pairs.
        """
        initial_state = TrafficState()
        for i, (start, end) in enumerate(start_end_pairs):
            if start in self.nodes and end in self.nodes:
                initial_state.complete.append(i)
                initial_state.paths.append([start])
            else:
                return [[]] * len(start_end_pairs)

        states = [(0, initial_state)]
        result = [[]] * len(start_end_pairs)
        result_cost = float("inf")

        while states:
            # Pop the current state off the stack
            (curr_cost, curr_state) = states.pop(0)
            if curr_cost >= result_cost:
                continue
            if len(curr_state.complete) == 0 and len(curr_state.incomplete) == 0:
                # All agents have reached destination, update result if needed
                if curr_cost < result_cost:
                    result = curr_state.paths
                    result_cost = curr_cost
                    continue
            elif len(curr_state.incomplete):
                for i in curr_state.incomplete:
                    path = curr_state.paths[i]
                    # Create a new state for each neighbor
                    for node, _ in self.graph.get(path[-1], []):
                        new_state = TrafficState()
                        new_state.incomplete = curr_state.incomplete.copy()
                        new_state.complete = curr_state.complete.copy()
                        new_state.paths = copy.deepcopy(curr_state.paths)

                        new_state.incomplete.remove(i)
                        new_state.complete.append(i)
                        new_state.paths[i].append(node)

                        # Update cost if we have completed the vertex
                        new_cost = curr_cost
                        if len(new_state.incomplete) == 0:
                            last_move = []
                            for i in new_state.complete:
                                path = new_state.paths[i]
                                last_move.append([path[-2], path[-1]])
                            new_cost += sum(self.compute_multi_path_cost(last_move))
                        if new_cost < result_cost:
                            states.append((new_cost, new_state))
            else:
                # If we pop a complete vertex:
                # 1. Do A* Star, and advance everyone by their proposed moves
                # 2. If no conflict, add the new state to the state list
                # 3. If there are conflicts, expand the node as if we were dealing
                #    with an incomplete vertex
                self.clear_edge_queues()

                next_move = {}
                path_impossible = False
                for i in curr_state.complete:
                    path = curr_state.paths[i]
                    if path[-1] == start_end_pairs[i][1]:
                        continue
                    a_star_path = self.a_star_single_traversal(
                        path[-1], start_end_pairs[i][1]
                    )
                    if a_star_path == []:
                        path_impossible = True
                        break
                    next_move[i] = a_star_path[1]
                if path_impossible:
                    continue

                if len(next_move.values()) == len(set(next_move.values())):
                    # There is no conflict, the moves are unique
                    new_cost = curr_cost
                    new_state = TrafficState()
                    new_state.paths = curr_state.paths.copy()
                    moves = []
                    for i, move in next_move.items():
                        path = curr_state.paths[i]
                        moves.append((path[-1], move))
                        new_state.paths[i].append(move)
                        new_state.complete.append(i)
                    new_cost += sum(self.compute_multi_path_cost(moves))
                    if new_cost < result_cost:
                        states.append((new_cost, new_state))
                else:
                    # There is a conflict, expand the vertex completely
                    new_state = TrafficState()
                    new_state.incomplete = list(next_move.keys())
                    new_state.paths = curr_state.paths.copy()
                    if curr_cost < result_cost:
                        states.append((curr_cost, new_state))
            # Sort queue by lowest cost
            states.sort(key=lambda x: x[0])
        return result

    def find_all_paths(self, start: str, end: str) -> List[List[str]]:
        """
        Finds all the potential paths between two nodes.

        Parameters
        __________
        start : str
        end : str
            Two graph nodes

        Returns
        _______
        A list of all possible paths.
        """
        paths = []

        def dfs(path, visited):
            if path[-1] in visited:
                return
            if path[-1] == end:
                paths.append(path.copy())
                return
            visited.append(path[-1])
            for node, _ in self.graph.get(path[-1], []):
                path.append(node)
                dfs(path, visited)
                path.pop()
            visited.pop()

        dfs([start], [])
        return paths

    def find_optimal_solutions(self, start_end_pairs) -> List[List[List[str]]]:
        """
        Finds every possible optimal list of pathways that correspond to the
        given start and end pairs. Looks at every possible combination of paths
        and finds the paths with the least cost. If any start and end pair is
        invalid, the method will return an empty list.

        Parameters
        __________
        start_and_end_pairs : List[List[str]]
            A list of start and end pairs of nodes to find paths for

        Returns
        _______
        A list of all possible pathway combinations to yield an optimal
        solution.
        """
        # Find all pathways for the start and end pairs
        all_agent_paths = []
        for start, end in start_end_pairs:
            all_indiv_paths = self.find_all_paths(start, end)
            if len(all_indiv_paths) == 0:
                return []
            all_agent_paths.append(all_indiv_paths)

        # Generate every combination of paths
        all_path_combos = []
        for i in range(len(all_agent_paths)):
            if len(all_path_combos) == 0:
                all_path_combos = [[path] for path in all_agent_paths[i]]
                continue
            new_all_path_combos = []
            for new_path in all_agent_paths[i]:
                combos_with_path = [path + [new_path] for path in all_path_combos]
                new_all_path_combos += combos_with_path
            all_path_combos = new_all_path_combos

        # Of the combination of all paths, determine the optimal solutions
        optimal_solutions = []
        result_cost = float("inf")
        for paths in all_path_combos:
            cost = sum(self.compute_multi_path_cost(paths))
            if cost < result_cost:
                optimal_solutions = [paths]
                result_cost = cost
            elif cost == result_cost:
                optimal_solutions.append(paths)
        return optimal_solutions
